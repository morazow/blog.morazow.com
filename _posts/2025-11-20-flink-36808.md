---
layout: post
created_at: "2025-11-20 13:54"
tags: apache-flink flink java
title: "[DRAFT] Debugging FLINK-36808 Issue"
published: true
---

Recently I picked up the [FLINK-36808](https://issues.apache.org/jira/browse/FLINK-36808) bug in the Apache Flink project. The solution to bug covers topics such as SQL LookupJoin, Flink SQL Planner, and Volcano optimizer (which is provided by the Apache Calcite project).

In this post I describe my experience debugging the issue and the lessons learned along the way. You can already find the pull request with the fix here [PR #26514](https://github.com/apache/flink/pull/26514).

The issue was internally reported by my colleague [Jun Qin]() and initial investigations were done by my teammate [Qingsheng Ren](). Let us start by first trying to understand the issue.

As mentioned in the ticket, given the union query of two lookup joins on the dimension tables, we get wrong results.

```sql
-- Data of table `stream`:
-- (1, Alice)
-- (2, Bob)
CREATE TEMPORARY TABLE `stream` (
    `id` BIGINT,
    `name` STRING,
    `txn_time` as proctime(),
    PRIMARY KEY (`id`) NOT ENFORCED
) WITH (
  'connector' = 'jdbc',
  'url' = 'jdbc:postgresql://localhost:5432/postgres',
  'table-name' = 'stream',
  'username' = 'postgres',
  'password' = 'postgres'
);

-- Data of table `dim`:
-- (1, OK)
-- (2, OK)
CREATE TEMPORARY TABLE `dim` (
    `id` BIGINT,
    `status` STRING,
    PRIMARY KEY (`id`) NOT ENFORCED
) WITH (
  'connector' = 'jdbc',
  'url' = 'jdbc:postgresql://localhost:5432/postgres',
  'table-name' = 'dim',
  'username' = 'postgres',
  'password' = 'postgres'
);

-- Lookup join two tables twice with different filter, and union them together
SELECT
     s.id,
     s.name,
     s.txn_time,
     d.status
FROM `stream` AS `s` INNER JOIN `dim` FOR SYSTEM_TIME AS OF `s`.`txn_time` AS `d`
ON
     `s`.`id` = `d`.`id`
WHERE
     `d`.`status` = 'OK'
UNION ALL
SELECT
     s.id,
     s.name,
     s.txn_time,
     d.status
FROM `stream` AS `s` INNER JOIN `dim` FOR SYSTEM_TIME AS OF `s`.`txn_time` AS `d`
ON
     `s`.`id` = `d`.`id`
WHERE
     `d`.`status` = 'NOT_EXISTS';
```

We expect to get the following results:

```txt
1, Alice 2024-11-27 11:52:19.332, OK
2, Bob   2024-11-27 11:52:19.332, OK
```

However, the actual results we got were:

```txt
1, Alice, 2024-11-27 11:52:19.332, OK
2, Bob,   2024-11-27 11:52:19.332, OK
1, Alice, 2024-11-27 11:52:19.333, NOT_EXISTS
2, Bob,   2024-11-27 11:52:19.333, NOT_EXISTS
```

This is obviously wrong, since there are no statuses with value `NOT_EXISTS` in the dimension `dim` table.

And SQL plans reported on the ticket seem correct.

Abstract syntax tree:

```txt
LogicalUnion(all=[true])
:- LogicalProject(id=[$0], name=[$1], txn_time=[$2], status=[$4])
:  +- LogicalFilter(condition=[=($4, _UTF-16LE'OK')])
:     +- LogicalCorrelate(correlation=[$cor0], joinType=[inner], requiredColumns=[{0, 2}])
:        :- LogicalProject(id=[$0], name=[$1], txn_time=[PROCTIME()])
:        :  +- LogicalTableScan(table=[[default_catalog, default_database, stream]])
:        +- LogicalFilter(condition=[=($cor0.id, $0)])
:           +- LogicalSnapshot(period=[$cor0.txn_time])
:              +- LogicalTableScan(table=[[default_catalog, default_database, dim]])
+- LogicalProject(id=[$0], name=[$1], txn_time=[$2], status=[$4])
   +- LogicalFilter(condition=[=($4, _UTF-16LE'NOT_EXISTS')])
      +- LogicalCorrelate(correlation=[$cor1], joinType=[inner], requiredColumns=[{0, 2}])
         :- LogicalProject(id=[$0], name=[$1], txn_time=[PROCTIME()])
         :  +- LogicalTableScan(table=[[default_catalog, default_database, stream]])
         +- LogicalFilter(condition=[=($cor1.id, $0)])
            +- LogicalSnapshot(period=[$cor1.txn_time])
               +- LogicalTableScan(table=[[default_catalog, default_database, dim]])
```

Optimized physical plan:

```txt
Calc(select=[id, name, PROCTIME_MATERIALIZE(txn_time) AS txn_time, status])
+- Union(all=[true], union=[id, name, txn_time, status])
   :- Calc(select=[id, name, txn_time, CAST(_UTF-16LE'OK':VARCHAR(2147483647) CHARACTER SET "UTF-16LE" AS VARCHAR(2147483647) CHARACTER SET "UTF-16LE") AS status])
   :  +- LookupJoin(table=[default_catalog.default_database.dim], joinType=[InnerJoin], lookup=[id=id], select=[id, name, txn_time, id])
   :     +- Calc(select=[id, name, PROCTIME() AS txn_time])
   :        +- TableSourceScan(table=[[default_catalog, default_database, stream]], fields=[id, name])
   +- Calc(select=[id, name, txn_time, CAST(_UTF-16LE'NOT_EXISTS':VARCHAR(2147483647) CHARACTER SET "UTF-16LE" AS VARCHAR(2147483647) CHARACTER SET "UTF-16LE") AS status])
      +- LookupJoin(table=[default_catalog.default_database.dim], joinType=[InnerJoin], lookup=[id=id], select=[id, name, txn_time, id])
         +- Calc(select=[id, name, PROCTIME() AS txn_time])
            +- TableSourceScan(table=[[default_catalog, default_database, stream]], fields=[id, name])
```

And optimized execution plan:

```txt
Calc(select=[id, name, PROCTIME_MATERIALIZE(txn_time) AS txn_time, status])
+- Union(all=[true], union=[id, name, txn_time, status])
   :- Calc(select=[id, name, txn_time, CAST('OK' AS VARCHAR(2147483647)) AS status])
   :  +- LookupJoin(table=[default_catalog.default_database.dim], joinType=[InnerJoin], lookup=[id=id], select=[id, name, txn_time, id])(reuse_id=[1])
   :     +- Calc(select=[id, name, PROCTIME() AS txn_time])
   :        +- TableSourceScan(table=[[default_catalog, default_database, stream]], fields=[id, name])
   +- Calc(select=[id, name, txn_time, CAST('NOT_EXISTS' AS VARCHAR(2147483647)) AS status])
      +- Reused(reference_id=[1])
```

I have also run the same query using our internal Flink engines or using MySQL as another database, but the results were the same. Thus fixing this bug in the open-source Apache Flink is important, all other enterprise Flink distributions will also benefit.

## Understanding the Issue

From the quick look at the optimized execution plan, we can see that the first lookup join is reused. To make sure that this is not the source of the problem, we can disable the reuse by setting the following configuration:

```txt
SET table.optimizer.reuse-sub-plan-enabled=false;
```

We are still getting the wrong results.

To better debug the issue, it is a good idea to create and reproduce the issue in the tests. After looking into the planner tests I came up with a test case using the `'values'` connector for both tables. For example, we can update the properties of the dimension table as below:

```scala
val dimTableId = TestValuesTableFactory.registerData(Seq(row(1L, "OK"), row(2L, "OK")))
val dimTableDDL =
  s"""
     | CREATE TABLE `dim` (
     |   `id` BIGINT,
     |   `status` STRING,
     |   PRIMARY KEY (`id`) NOT ENFORCED
     | ) WITH (
     |   'connector' = 'values',
     |   'data-id' = '$dimTableId'
     | )
     |""".stripMargin
tEnv.executeSql(dimTableDDL)
```

Hold and behold, the issue does not happen! Okay, this is good since sign, we can now try to find the reasons for differences when using different connectors.

### Comparing Planner Transformations

We know that two queries behave differently when used with different connectors, to investigate further, let's compare each query transformation. To do so, enable the debug logging or add log statements in the [FlinkChainedProgram#optimize](https://github.com/apache/flink/blob/master/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/plan/optimize/program/FlinkChainedProgram.scala#L62-L66) method.

(There are many optimization steps in the program they require a topic of their own)

Listing all the optimization steps and comparing each plan (with minor simplifications), we can see the following differences.

#### Logical Rewrite

The first difference is in the logical rewrite step.

<style>
.diff {
    pre { background-color: #282c34; color: #abb2bf; font-size: 10px; }
    .DiffChange {background-color: #44403c; color: #e0af68}
    .DiffText {background-color: #564d41}
}

/* Tree styles */
ul.tree {
  font-size: 14px;
  list-style: none;
  margin: 0;
  padding-top: 5px;
  padding-bottom: 20px;
  padding-left: 1em;
  border-radius: 5px;
  background-color: #2b2b2b;
  color: #a9b7c6;
}
ul.tree ul {
  list-style: none;
  margin-left: .6em;
  padding-left: .6em;
}
ul.tree li {
  position: relative;
  line-height: 1.4em;
}

* Common row styling */
.row {
  display: flex;
  align-items: center;
  border-radius: 3px;
}

/* Only this .row gets the highlight */
.row.highlighted {
  /* pull the blue back out to the very left edge */
  margin-left: -1em;
  padding-left: 1em;
  background-color: #214283;
}

icon {
  width: 16px;
  height: 16px;
  margin-right: 4px;
}

/* Toggle icons */
.toggle {
  display: inline-block;
  width: 1em;
  color: #BBB;
}

/* colouring */
.field-name { color: #CC7832; padding-right: 3px }  /* orange fields */
.type       { color: #9876AA; padding-left: 3px }   /* purple type names */
.value      { color: #6A8759; padding-left: 0 }     /* green values */
.id         { color: #d2d2cc; padding-left: 3px }     /* white values */

li.highlighted {
  /* pull the blue back out to the very left edge */
  margin-left: -7em;
  padding-left: 7em;
  background-color: #214283;
  border-radius: 3px;
}
</style>

<table style="table-layout:fixed; width: 1500px;">
<tr style="text-align: center;">
    <th><em>Logical Rewrite rule for union all query using JDBC connector</em></th>
    <th><em>Logical Rewrite rule for union all query using test 'values' connector</em></th>
</tr>
<tr class="diff">
<td>
<pre>
optimize 'logical_rewrite' cost 29 ms.

original input:

FlinkLogicalUnion(all=[true])
:- FlinkLogicalCalc(select=[id, name, txn_time, CAST(_UTF-16LE'OK':VARCHAR(2147483647)) AS status])
:  +- FlinkLogicalJoin(condition=[=($0, $3)], joinType=[inner])
:     :- FlinkLogicalCalc(select=[id, name, PROCTIME() AS txn_time])
:     :  +- FlinkLogicalTableSourceScan(table=[[default_catalog, default_database, stream]], fields=[id, name])
:     +- FlinkLogicalCalc(select=[id], where=[=(status, _UTF-16LE'OK':VARCHAR(2147483647))])
:        +- FlinkLogicalSnapshot(period=[$cor0.txn_time])
:           +- FlinkLogicalTableSourceScan(table=[[default_catalog, default_database, dim]], fields=[id, status])
+- FlinkLogicalCalc(select=[id, name, txn_time, CAST(_UTF-16LE'NOT_EXISTS':VARCHAR(2147483647)) AS status])
   +- FlinkLogicalJoin(condition=[=($0, $3)], joinType=[inner])
      :- FlinkLogicalCalc(select=[id, name, PROCTIME() AS txn_time])
      :  +- FlinkLogicalTableSourceScan(table=[[default_catalog, default_database, stream]], fields=[id, name])
      +- FlinkLogicalCalc(select=[id], where=[=(status, _UTF-16LE'NOT_EXISTS':VARCHAR(2147483647))])
         +- FlinkLogicalSnapshot(period=[$cor1.txn_time])
            +- FlinkLogicalTableSourceScan(table=[[default_catalog, default_database, dim]], fields=[id, status])

optimize output:

FlinkLogicalUnion(all=[true])
:- FlinkLogicalCalc(select=[id, name, txn_time, CAST(_UTF-16LE'OK':VARCHAR(2147483647)) AS status])
:  +- FlinkLogicalJoin(condition=[=($0, $3)], joinType=[inner])
:     :- FlinkLogicalCalc(select=[id, name, PROCTIME() AS txn_time])
:     :  +- FlinkLogicalTableSourceScan(table=[[default_catalog, default_database, stream]], fields=[id, name])
:     +- FlinkLogicalSnapshot(period=[$cor0.txn_time])
<span class="DiffChange">:        +- FlinkLogicalCalc(select=[id])</span>
<span class="DiffChange">:           +- FlinkLogicalTableSourceScan(table=[[default_catalog, default_database, dim, filter=[</span><span class="DiffText">=(status, _UTF-16LE'OK':VARCHAR(2147483647))</span><span class="DiffChange">]]], fields=[id, status])</span>
+- FlinkLogicalCalc(select=[id, name, txn_time, CAST(_UTF-16LE'NOT_EXISTS':VARCHAR(2147483647)) AS status])
   +- FlinkLogicalJoin(condition=[=($0, $3)], joinType=[inner])
      :- FlinkLogicalCalc(select=[id, name, PROCTIME() AS txn_time])
      :  +- FlinkLogicalTableSourceScan(table=[[default_catalog, default_database, stream]], fields=[id, name])
      +- FlinkLogicalSnapshot(period=[$cor1.txn_time])
<span class="DiffChange">         +- FlinkLogicalCalc(select=[id])</span>
<span class="DiffChange">            +- FlinkLogicalTableSourceScan(table=[[default_catalog, default_database, dim, filter=[</span><span class="DiffText">=(status, _UTF-16LE'NOT_EXISTS':VARCHAR(2147483647))</span><span class="DiffChange">]]], fields=[id, status])</span>

</pre>
</td>
<td>
<pre>
optimize 'logical_rewrite' cost 29 ms.

original input:

FlinkLogicalUnion(all=[true])
:- FlinkLogicalCalc(select=[id, name, txn_time, CAST(_UTF-16LE'OK':VARCHAR(2147483647)) AS status])
:  +- FlinkLogicalJoin(condition=[=($0, $3)], joinType=[inner])
:     :- FlinkLogicalCalc(select=[id, name, PROCTIME() AS txn_time])
:     :  +- FlinkLogicalTableSourceScan(table=[[default_catalog, default_database, stream]], fields=[id, name])
:     +- FlinkLogicalCalc(select=[id], where=[=(status, _UTF-16LE'OK':VARCHAR(2147483647))])
:        +- FlinkLogicalSnapshot(period=[$cor0.txn_time])
:           +- FlinkLogicalTableSourceScan(table=[[default_catalog, default_database, dim]], fields=[id, status])
+- FlinkLogicalCalc(select=[id, name, txn_time, CAST(_UTF-16LE'NOT_EXISTS':VARCHAR(2147483647)) AS status])
   +- FlinkLogicalJoin(condition=[=($0, $3)], joinType=[inner])
      :- FlinkLogicalCalc(select=[id, name, PROCTIME() AS txn_time])
      :  +- FlinkLogicalTableSourceScan(table=[[default_catalog, default_database, stream]], fields=[id, name])
      +- FlinkLogicalCalc(select=[id], where=[=(status, _UTF-16LE'NOT_EXISTS':VARCHAR(2147483647))])
         +- FlinkLogicalSnapshot(period=[$cor1.txn_time])
            +- FlinkLogicalTableSourceScan(table=[[default_catalog, default_database, dim]], fields=[id, status])

optimized output:

FlinkLogicalUnion(all=[true])
:- FlinkLogicalCalc(select=[id, name, txn_time, CAST(_UTF-16LE'OK':VARCHAR(2147483647)) AS status])
:  +- FlinkLogicalJoin(condition=[=($0, $3)], joinType=[inner])
:     :- FlinkLogicalCalc(select=[id, name, PROCTIME() AS txn_time])
:     :  +- FlinkLogicalTableSourceScan(table=[[default_catalog, default_database, stream]], fields=[id, name])
:     +- FlinkLogicalSnapshot(period=[$cor0.txn_time])
<span class="DiffChange">:        +- FlinkLogicalCalc(select=[id]</span><span class="DiffText">, where=[=(status, _UTF-16LE'OK':VARCHAR(2147483647))]</span><span class="DiffChange">)</span>
<span class="DiffChange">:           +- FlinkLogicalTableSourceScan(table=[[default_catalog, default_database, dim, filter=[]]], fields=[id, status])</span>
+- FlinkLogicalCalc(select=[id, name, txn_time, CAST(_UTF-16LE'NOT_EXISTS':VARCHAR(2147483647)) AS status])
   +- FlinkLogicalJoin(condition=[=($0, $3)], joinType=[inner])
      :- FlinkLogicalCalc(select=[id, name, PROCTIME() AS txn_time])
      :  +- FlinkLogicalTableSourceScan(table=[[default_catalog, default_database, stream]], fields=[id, name])
      +- FlinkLogicalSnapshot(period=[$cor1.txn_time])
<span class="DiffChange">         +- FlinkLogicalCalc(select=[id]</span><span class="DiffText">, where=[=(status, _UTF-16LE'NOT_EXISTS':VARCHAR(2147483647))]</span><span class="DiffChange">)</span>
<span class="DiffChange">            +- FlinkLogicalTableSourceScan(table=[[default_catalog, default_database, dim, filter=[]]], fields=[id, status])</span>

</pre>
</td>
</tr>
</table>

Well, what is going on here?

We have the same logical input, but the optimized results are different. After discussing with my colleagues, I realized that the JDBC connector supports [filter push down](https://github.com/apache/flink-connector-jdbc/blob/main/flink-connector-jdbc-core/src/main/java/org/apache/flink/connector/jdbc/core/table/source/JdbcDynamicTableSource.java#L70) capability. Because of this, the Flink SQL planner pushes the filter condition down to the table level when using the JDBC connector. This is not the case for the test **values** connector, and the filter/where condition is kept on the calculated logical expression that will be applied after the table scan.

{% include note.html content="<em>The filter push down optimization is important since it allows us to filter the data at the source level, reducing the amount of data transferred over the network, improving performance of the SQL queries.</em>" %}

Okay, this is fine. Let's check the next difference.

#### Physical Optimization

The second difference happens in the physical optimization step.

<table style="table-layout:fixed; width:1500px;">
<tr style="text-align: center;">
    <th><em>Physical Optimization rule for union all query using JDBC connector</em></th>
    <th><em>Physical Optimization rule for union all query using test 'values' connector</em></th>
</tr>
<tr class="diff">
<td>
<pre>
optimize 'physical' cost 29 ms.

original input:

FlinkLogicalCalc(select=[id, name, PROCTIME_MATERIALIZE(txn_time) AS txn_time, status])
+- FlinkLogicalUnion(all=[true])
   :- FlinkLogicalCalc(select=[id, name, txn_time, CAST(_UTF-16LE'OK':VARCHAR(2147483647)) AS status])
   :  +- FlinkLogicalJoin(condition=[=($0, $3)], joinType=[inner])
   :     :- FlinkLogicalCalc(select=[id, name, PROCTIME() AS txn_time])
   :     :  +- FlinkLogicalTableSourceScan(table=[[default_catalog, default_database, stream]], fields=[id, name])
   :     +- FlinkLogicalSnapshot(period=[$cor0.txn_time])
<span class="DiffChange">   :        +- FlinkLogicalCalc(select=[id])</span>
<span class="DiffChange">   :           +- FlinkLogicalTableSourceScan(table=[[default_catalog, default_database, dim, filter=[</span><span class="DiffText">=(status, _UTF-16LE'OK':VARCHAR(2147483647))</span><span class="DiffChange">]]], fields=[id, status])</span>
   +- FlinkLogicalCalc(select=[id, name, txn_time, CAST(_UTF-16LE'NOT_EXISTS':VARCHAR(2147483647)) AS status])
      +- FlinkLogicalJoin(condition=[=($0, $3)], joinType=[inner])
         :- FlinkLogicalCalc(select=[id, name, PROCTIME() AS txn_time])
         :  +- FlinkLogicalTableSourceScan(table=[[default_catalog, default_database, stream]], fields=[id, name])
         +- FlinkLogicalSnapshot(period=[$cor1.txn_time])
<span class="DiffChange">            +- FlinkLogicalCalc(select=[id])</span>
<span class="DiffChange">               +- FlinkLogicalTableSourceScan(table=[[default_catalog, default_database, dim, filter=[</span><span class="DiffText">=(status, _UTF-16LE'NOT_EXISTS':VARCHAR(2147483647))</span><span class="DiffChange">]]], fields=[id, status])</span>

optimized output:

Calc(select=[id, name, PROCTIME_MATERIALIZE(txn_time) AS txn_time, status])
+- Union(all=[true], union=[id, name, txn_time, status])
   :- Calc(select=[id, name, txn_time, CAST(_UTF-16LE'OK':VARCHAR(2147483647)) AS status])
<span class="DiffChange">   :  +- LookupJoin(table=[default_catalog.default_database.dim], joinType=[InnerJoin], lookup=[</span><span    class="DiffText">id=id</span><span class="DiffChange">], select=[id, name, txn_time, id], upsertKey=[[0]])</span>
   :     +- Calc(select=[id, name, PROCTIME() AS txn_time])
   :        +- TableSourceScan(table=[[default_catalog, default_database, stream]], fields=[id, name])
   +- Calc(select=[id, name, txn_time, CAST(_UTF-16LE'NOT_EXISTS':VARCHAR(2147483647)) AS status])
<span class="DiffChange">      +- LookupJoin(table=[default_catalog.default_database.dim], joinType=[InnerJoin], lookup=[</span><span    class="DiffText">id=id</span><span class="DiffChange">], select=[id, name, txn_time, id], upsertKey=[[0]])</span>
         +- Calc(select=[id, name, PROCTIME() AS txn_time])
            +- TableSourceScan(table=[[default_catalog, default_database, stream]], fields=[id, name])

</pre>
</td>
<td>
<pre>
optimize 'physical' cost 29 ms.

original input:

FlinkLogicalCalc(select=[id, name, PROCTIME_MATERIALIZE(txn_time) AS txn_time, status])
+- FlinkLogicalUnion(all=[true])
   :- FlinkLogicalCalc(select=[id, name, txn_time, CAST(_UTF-16LE'OK':VARCHAR(2147483647)) AS status])
   :  +- FlinkLogicalJoin(condition=[=($0, $3)], joinType=[inner])
   :     :- FlinkLogicalCalc(select=[id, name, PROCTIME() AS txn_time])
   :     :  +- FlinkLogicalTableSourceScan(table=[[default_catalog, default_database, stream]], fields=[id, name])
   :     +- FlinkLogicalSnapshot(period=[$cor0.txn_time])
<span class="DiffChange">   :        +- FlinkLogicalCalc(select=[id]</span><span class="DiffText">, where=[=(status, _UTF-16LE'OK':VARCHAR(2147483647))]</span><span class="DiffChange">)</span>
<span class="DiffChange">   :           +- FlinkLogicalTableSourceScan(table=[[default_catalog, default_database, dim, filter=[]]], fields=[id, status])</span>
   +- FlinkLogicalCalc(select=[id, name, txn_time, CAST(_UTF-16LE'NOT_EXISTS':VARCHAR(2147483647)) AS status])
      +- FlinkLogicalJoin(condition=[=($0, $3)], joinType=[inner])
         :- FlinkLogicalCalc(select=[id, name, PROCTIME() AS txn_time])
         :  +- FlinkLogicalTableSourceScan(table=[[default_catalog, default_database, stream]], fields=[id, name])
         +- FlinkLogicalSnapshot(period=[$cor1.txn_time])
<span    class="DiffChange">            +- FlinkLogicalCalc(select=[id]</span><span class="DiffText">, where=[=(status, _UTF-16LE'NOT_EXISTS':VARCHAR(2147483647))]</span><span class="DiffChange">)</span>
<span class="DiffChange">               +- FlinkLogicalTableSourceScan(table=[[default_catalog, default_database, dim, filter=[]]], fields=[id, status])</span>

optimized output:

Calc(select=[id, name, PROCTIME_MATERIALIZE(txn_time) AS txn_time, status])
+- Union(all=[true], union=[id, name, txn_time, status])
   :- Calc(select=[id, name, txn_time, CAST(_UTF-16LE'OK':VARCHAR(2147483647)) AS status])
<span class="DiffChange">   :  +- LookupJoin(table=[default_catalog.default_database.dim], joinType=[InnerJoin], lookup=[</span><span    class="DiffText">status=_UTF-16LE'OK', id=id], where=[=(status, _UTF-16LE'OK':VARCHAR(2147483647))</span><span class="DiffChange">], select=[id, name, txn_time, id], upsertKey=[[0]])</span>
   :     +- Calc(select=[id, name, PROCTIME() AS txn_time])
   :        +- TableSourceScan(table=[[default_catalog, default_database, stream]], fields=[id, name])
   +- Calc(select=[id, name, txn_time, CAST(_UTF-16LE'NOT_EXISTS':VARCHAR(2147483647)) AS status])
<span class="DiffChange">      +- LookupJoin(table=[default_catalog.default_database.dim], joinType=[InnerJoin], lookup=[</span><span class="DiffText">status=_UTF-16LE'NOT_EXISTS', id=id], where=[=(status, _UTF-16LE'NOT_EXISTS':VARCHAR(2147483647))</span><span class="DiffChange">], select=[id, name, txn_time, id], upsertKey=[[0]])</span>
         +- Calc(select=[id, name, PROCTIME() AS txn_time])
            +- TableSourceScan(table=[[default_catalog, default_database, stream]], fields=[id, name])

</pre>
</td>
</tr>
</table>

This transformation also looks fine. But let's pay closer attention to understand what is going on here.

This step converts the join into the lookup join, adds additional information, e.g, `joinType`, `select` and `lookup` definitions. It adds `id` as a lookup key to both transformations. However, for the **values** connector plan (on the right) the lookup definition includes the `status` column as a lookup key. Plus, it also contains information about the filter condition in `where` definition.

But on the JDBC connector plan (on the left) does not include `where` definition and status in the `lookup` definition. This shouldn't be a problem for JDBC or any other source that support filter pushdowns since the filter condition (here `status` column comparison) is pushed down in the table scan.

But still, it would be helpful to include the filter pushdowns in the lookup join definitions in query explanations.

{% include warning.html content="<em>This is also foreshadowing for the source of the bug.</em>" %}

At this point, I have conducted several debug sessions and discussions with my colleagues, but I still could not identify the root cause of the bug.

I was thinking maybe some other optimization rule is messing up the filter pushdowns, e.g., discards them. Thus, I tried to create minimal test case that only applies the relevant physical optimization rules. You can find the example file [here]().

While debugging and reading other test cases, I noticed that the **values** connector could simulate the filter pushdowns, by just adding `filterable-fields` property to the table creation.

By updating the dimension table create statement to:

```scala
val dimTableId = TestValuesTableFactory.registerData(Seq(row(1L, "OK"), row(2L, "OK")))
val dimTableDDL =
  s"""
     | CREATE TABLE `dim` (
     |   `id` BIGINT,
     |   `status` STRING,
     |   PRIMARY KEY (`id`) NOT ENFORCED
     | ) WITH (
     |   'connector' = 'values',
     |   'filterable-fields' = 'id;status',
     |   'data-id' = '$dimTableId'
     | )
     |""".stripMargin

tEnv.executeSql(dimTableDDL
```

We have no the reproducible test case, and no need to depend on the databases. Okay good, but we are still have no clue about the root cause of the bug.

Continuing debugging, I added breakpoint on the [StreamPhysicalUnionRule#440](https://github.com/apache/flink/blob/0ce8cb1f2bd13c7cfca8b777972db0cbaa99af46/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/plan/rules/physical/stream/StreamPhysicalUnionRule.scala#L43) and noticed that the logical `FlinkLogicalJoin` relations for both inputs are the same.

<ul class="tree">
  <li>
    <div class="row">
      <span class="toggle"></span>
      <img class="icon" src="/assets/icons/field.svg" >
      <span class="field-name">this</span> =
      <span class="type">StreamPhysicalUnionRule</span>
      <span class="value">@13203</span>
    </div>
  </li>
  <li>
    <div class="row">
      <span class="toggle"></span>
      <img class="icon" src="/assets/icons/field.svg" >
      <span class="field-name">rel</span> =
      <span class="type">FlinkLogicalUnion</span>
      <span class="value">@13204</span>
    </div>
  </li>
  <li>
    <div class="row highlighted">
      <span class="toggle">▾</span>
      <img class="icon" src="/assets/icons/variablesTab.svg">
      <span class="field-name">union</span> =
      <span class="type">FlinkLogicalUnion</span>
      <span class="value">@13204</span>
    </div>
    <ul>
      <li>
        <div class="row">
          <span class="toggle"></span>
          <img class="icon" src="/assets/icons/field.svg">
          <span class="field-name">id</span> =
          <span class="id">888</span>
        </div>
      </li>
      <li>
        <div class="row">
          <span class="toggle">▾</span>
          <img class="icon" src="/assets/icons/field.svg">
          <span class="field-name">inputs</span> =
          <span class="type">RegularImmutableList</span>
          <span class="value">@13218</span>
        </div>
        <ul>
          <li>
            <div class="row">
              <span class="toggle">▾</span>
              <img class="icon" src="/assets/icons/variablesTab.svg">
              <span class="field-name">0</span> =
              <span class="type">RelSubset</span>
              <span class="value">@13227</span>
            </div>
            <ul>
              <li>
                <div class="row">
                  <span class="toggle"></span>
                  <img class="icon" src="/assets/icons/field.svg">
                  <span class="field-name">id</span> =
                  <span class="id">876</span>
                </div>
              </li>
              <li>
                <div class="row">
                  <span class="toggle">▾</span>
                  <img class="icon" src="/assets/icons/field.svg">
                  <span class="field-name">best</span> =
                  <span class="type">FlinkLogicalCalc</span>
                  <span class="value">@13232</span>
                </div>
                <ul>
                  <li>
                    <div class="row">
                      <span class="toggle"></span>
                      <img class="icon" src="/assets/icons/field.svg">
                      <span class="field-name">id</span> =
                      <span class="id">875</span>
                    </div>
                  </li>
                  <li>
                    <div class="row">
                      <span class="toggle">▾</span>
                      <img class="icon" src="/assets/icons/field.svg">
                      <span class="field-name">input</span> =
                      <span class="type">RelSubset</span>
                      <span class="value">@13237</span>
                    </div>
                    <ul>
                      <li>
                        <div class="row">
                          <span class="toggle"></span>
                          <img class="icon" src="/assets/icons/field.svg">
                          <span class="field-name">id</span> =
                          <span class="id">874</span>
                        </div>
                      </li>
                      <li class="highlighted">
                        <div class="row">
                          <span class="toggle">▾</span>
                          <img class="icon" src="/assets/icons/field.svg">
                          <span class="field-name">best</span> =
                          <span class="type">FlinkLogicalJoin</span>
                          <span class="value">@13242</span>
                        </div>
                        <ul>
                          <li>
                            <div class="row">
                              <span class="toggle"></span>
                              <img class="icon" src="/assets/icons/field.svg">
                              <span class="field-name">id</span> =
                              <span class="id">873</span>
                            </div>
                          </li>
                          <li>
                            <div class="row">
                              <span class="toggle">▸</span>
                              <img class="icon" src="/assets/icons/field.svg">
                              <span class="field-name">joinType</span> =
                              <span class="type">JoinRelType</span>
                              <span class="value">@13255</span>
                            </div>
                          </li>
                          <li>
                            <div class="row">
                              <span class="toggle">▸</span>
                              <img class="icon" src="/assets/icons/field.svg">
                              <span class="field-name">condition</span> =
                              <span class="type">RexCall</span>
                              <span class="value">@13256</span>
                            </div>
                          </li>
                          <li>
                            <div class="row">
                              <span class="toggle">▸</span>
                              <img class="icon" src="/assets/icons/field.svg">
                              <span class="field-name">joinInfo</span> =
                              <span class="type">JoinInfo</span>
                              <span class="value">@13258</span>
                            </div>
                          </li>
                          <li>
                            <div class="row">
                              <span class="toggle">▸</span>
                              <img class="icon" src="/assets/icons/field.svg">
                              <span class="field-name">left</span> =
                              <span class="type">RelSubset</span>
                              <span class="value">@13259</span>
                            </div>
                          </li>
                          <li>
                            <div class="row">
                              <span class="toggle">▸</span>
                              <img class="icon" src="/assets/icons/field.svg">
                              <span class="field-name">right</span> =
                              <span class="type">RelSubset</span>
                              <span class="value">@13260</span>
                            </div>
                          </li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            <div class="row">
              <span class="toggle">▾</span>
              <img class="icon" src="/assets/icons/variablesTab.svg">
              <span class="field-name">1</span> =
              <span class="type">RelSubset</span>
              <span class="value">@13228</span>
            </div>
            <ul>
              <li>
                <div class="row">
                  <span class="toggle"></span>
                  <img class="icon" src="/assets/icons/field.svg">
                  <span class="field-name">id</span> =
                  <span class="value">886</span>
                </div>
              </li>
              <li>
                <div class="row">
                  <span class="toggle">▾</span>
                  <img class="icon" src="/assets/icons/field.svg">
                  <span class="field-name">best</span> =
                  <span class="type">FlinkLogicalCalc</span>
                  <span class="value">@13248</span>
                </div>
                <ul>
                  <li>
                    <div class="row">
                      <span class="toggle"></span>
                      <img class="icon" src="/assets/icons/field.svg">
                      <span class="field-name">id</span> =
                      <span class="id">885</span>
                    </div>
                  </li>
                  <li>
                    <div class="row">
                      <span class="toggle">▾</span>
                      <img class="icon" src="/assets/icons/field.svg">
                      <span class="field-name">input</span> =
                      <span class="type">RelSubset</span>
                      <span class="value">@13237</span>
                    </div>
                    <ul>
                      <li>
                        <div class="row">
                          <span class="toggle"></span>
                          <img class="icon" src="/assets/icons/field.svg">
                          <span class="field-name">id</span> =
                          <span class="id">874</span>
                        </div>
                      </li>
                      <li class="highlighted">
                        <div class="row">
                          <span class="toggle">▾</span>
                          <img class="icon" src="/assets/icons/field.svg">
                          <span class="field-name">best</span> =
                          <span class="type">FlinkLogicalJoin</span>
                          <span class="value">@13242</span>
                        </div>
                        <ul>
                          <li><div class="row">
                            <span class="toggle"></span>
                            <img class="icon" src="/assets/icons/field.svg">
                            <span class="field-name">id</span> =
                            <span class="id">873</span>
                          </div></li>
                          <li><div class="row">
                            <span class="toggle">▸</span>
                            <img class="icon" src="/assets/icons/field.svg">
                            <span class="field-name">joinType</span> =
                            <span class="type">JoinRelType</span>
                            <span class="value">@13255</span>
                          </div></li>
                          <li><div class="row">
                            <span class="toggle">▸</span>
                            <img class="icon" src="/assets/icons/field.svg">
                            <span class="field-name">condition</span> =
                            <span class="type">RexCall</span>
                            <span class="value">@13256</span>
                          </div></li>
                          <li><div class="row">
                            <span class="toggle">▸</span>
                            <img class="icon" src="/assets/icons/field.svg">
                            <span class="field-name">joinInfo</span> =
                            <span class="type">JoinInfo</span>
                            <span class="value">@13258</span>
                          </div></li>
                          <li><div class="row">
                            <span class="toggle">▸</span>
                            <img class="icon" src="/assets/icons/field.svg">
                            <span class="field-name">left</span> =
                            <span class="type">RelSubset</span>
                            <span class="value">@13259</span>
                          </div></li>
                          <li><div class="row">
                            <span class="toggle">▸</span>
                            <img class="icon" src="/assets/icons/field.svg">
                            <span class="field-name">right</span> =
                            <span class="type">RelSubset</span>
                            <span class="value">@13260</span>
                          </div></li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<br>
Somehow the SQL optimizer finds the best plan (cheapest cost plan) for the union with both logical joins equivalent.

Indeed, if we print the logical union relation before converting to the physical union, `System.out.println(union.explain())`:

<table>
<tr class="diff">
<td>
<pre>
Union: FlinkLogicalUnion(all=[true])
  FlinkLogicalCalc(subset=[rel#876:RelSubset#19.LOGICAL.any.None: 0.[NONE].[NONE]], select=[id, name, CAST('OK' AS VARCHAR(2147483647)) AS status])
    FlinkLogicalJoin(subset=[rel#874:RelSubset#18.LOGICAL.any.None: 0.[NONE].[NONE]], condition=[=($0, $2)], joinType=[inner])
      FlinkLogicalTableSourceScan(subset=[rel#867:RelSubset#14.LOGICAL.any.None: 0.[NONE].[NONE]], table=[[default_catalog, default_database, stream]], fields=[id, name])
      FlinkLogicalSnapshot(subset=[rel#872:RelSubset#17.LOGICAL.any.None: 0.[NONE].[NONE]], period=[$cor0.txn_time])
        FlinkLogicalCalc(subset=[rel#870:RelSubset#16.LOGICAL.any.None: 0.[NONE].[NONE]], select=[id])
<span class="DiffChange">          FlinkLogicalTableSourceScan(subset=[rel#868:RelSubset#15.LOGICAL.any.None: 0.[NONE].[NONE]], table=[[default_catalog, default_database, dim, filter=[=(status, _UTF-16LE'OK':VARCHAR(2147483647) CHARACTER SET "UTF-16LE")]]], fields=[id, status])</span>
  FlinkLogicalCalc(subset=[rel#886:RelSubset#24.LOGICAL.any.None: 0.[NONE].[NONE]], select=[id, name, CAST('NOT_EXISTS' AS VARCHAR(2147483647)) AS status])
    FlinkLogicalJoin(subset=[rel#874:RelSubset#18.LOGICAL.any.None: 0.[NONE].[NONE]], condition=[=($0, $2)], joinType=[inner])
      FlinkLogicalTableSourceScan(subset=[rel#867:RelSubset#14.LOGICAL.any.None: 0.[NONE].[NONE]], table=[[default_catalog, default_database, stream]], fields=[id, name])
      FlinkLogicalSnapshot(subset=[rel#872:RelSubset#17.LOGICAL.any.None: 0.[NONE].[NONE]], period=[$cor0.txn_time])
        FlinkLogicalCalc(subset=[rel#870:RelSubset#16.LOGICAL.any.None: 0.[NONE].[NONE]], select=[id])
<span class="DiffChange">          FlinkLogicalTableSourceScan(subset=[rel#868:RelSubset#15.LOGICAL.any.None: 0.[NONE].[NONE]], table=[[default_catalog, default_database, dim, filter=[=(status, _UTF-16LE'OK':VARCHAR(2147483647) CHARACTER SET "UTF-16LE")]]], fields=[id, status])</span>
</pre>
</td>
</tr>
</table>

We can see that the *FlinkLogicalJoin* for both inputs are exactly the same deep into the table scan. Both parts only filter the data if the `status` column is equal to the string `OK`.

This is good finding!

> At this point, I spent extra time debugging the LogicalJoin optimization rules, but it didn't lead to anything.

{% include tip.html content="<em>Now is also good time to update our tests and add unit test for then case when the filter condition are reversed. That is what happens if we filter for the non-existing</em> <b>status</b> <em>values on the first part of the union query?</em>" %}

But if both logical joins filter data matching the status `'OK'`, why do we get the following result with `NOT EXISTS` status rows?

```
1, Alice, 2024-11-27 11:52:19.332, OK
2, Bob,   2024-11-27 11:52:19.332, OK
1, Alice, 2024-11-27 11:52:19.333, NOT_EXISTS
2, Bob,   2024-11-27 11:52:19.333, NOT_EXISTS
```

Shouldn't all four rows have status as `OK`?

### Code Generation
